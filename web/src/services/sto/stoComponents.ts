/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from '@tanstack/react-query'
import { useStoContext, StoContext } from './stoContext'
import type * as Fetcher from './stoFetcher'
import { stoFetch } from './stoFetcher'
import type * as Schemas from './stoSchemas'

export type UsageReportUsageQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Timestamp indicating the end of the usage interval (in milliseconds since Unix epoch)
   *
   * @example 1670427991307
   * @format int64
   */
  timestamp: number
  /**
   * Usage calculation interval (in days)
   *
   * @default 30
   * @example 30
   * @format int64
   */
  interval?: number
}

export type UsageReportUsageError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type UsageReportUsageVariables = {
  queryParams: UsageReportUsageQueryParams
} & StoContext['fetcherOptions']

/**
 * Report usage
 */
export const fetchUsageReportUsage = (variables: UsageReportUsageVariables, signal?: AbortSignal) =>
  stoFetch<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, undefined, {}, UsageReportUsageQueryParams, {}>(
    { url: '/api/usage', method: 'get', ...variables, signal },
  )

/**
 * Report usage
 */
export const useUsageReportUsage = <TData = Schemas.UsageReportUsageResponseBody>(
  variables: UsageReportUsageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, TData>({
    queryKey: queryKeyFn({ path: '/api/usage', operationId: 'usageReportUsage', variables }),
    queryFn: ({ signal }) => fetchUsageReportUsage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type UsageUsageAllAccountsQueryParams = {
  /**
   * Timestamp indicating the end of the usage interval (in milliseconds since Unix epoch)
   *
   * @example 1670427991307
   * @format int64
   */
  timestamp: number
  /**
   * Usage calculation interval (in days)
   *
   * @default 30
   * @example 30
   * @format int64
   */
  interval?: number
}

export type UsageUsageAllAccountsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type UsageUsageAllAccountsVariables = {
  queryParams: UsageUsageAllAccountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Report usage for all accounts
 */
export const fetchUsageUsageAllAccounts = (variables: UsageUsageAllAccountsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.UsageUsageAllAccountsResponseBody,
    UsageUsageAllAccountsError,
    undefined,
    {},
    UsageUsageAllAccountsQueryParams,
    {}
  >({ url: '/api/usage/all-accounts', method: 'get', ...variables, signal })

/**
 * Report usage for all accounts
 */
export const useUsageUsageAllAccounts = <TData = Schemas.UsageUsageAllAccountsResponseBody>(
  variables: UsageUsageAllAccountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UsageUsageAllAccountsResponseBody, UsageUsageAllAccountsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.UsageUsageAllAccountsResponseBody, UsageUsageAllAccountsError, TData>({
    queryKey: queryKeyFn({ path: '/api/usage/all-accounts', operationId: 'usageUsageAllAccounts', variables }),
    queryFn: ({ signal }) => fetchUsageUsageAllAccounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type AccountsDeleteAccountDataPathParams = {
  /**
   * The ID of the account to delete data for
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type AccountsDeleteAccountDataError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type AccountsDeleteAccountDataVariables = {
  pathParams: AccountsDeleteAccountDataPathParams
} & StoContext['fetcherOptions']

/**
 * Delete all account data
 */
export const fetchAccountsDeleteAccountData = (variables: AccountsDeleteAccountDataVariables, signal?: AbortSignal) =>
  stoFetch<Schemas.Status, AccountsDeleteAccountDataError, undefined, {}, {}, AccountsDeleteAccountDataPathParams>({
    url: '/api/v2/accounts/{id}/data',
    method: 'delete',
    ...variables,
    signal,
  })

/**
 * Delete all account data
 */
export const useAccountsDeleteAccountData = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Status, AccountsDeleteAccountDataError, AccountsDeleteAccountDataVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Status, AccountsDeleteAccountDataError, AccountsDeleteAccountDataVariables>({
    mutationFn: (variables: AccountsDeleteAccountDataVariables) =>
      fetchAccountsDeleteAccountData({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ExemptionsListExemptionsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
}

export type ExemptionsListExemptionsHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Voluptate totam laborum.
   */
  ['X-Api-Key']?: string
}

export type ExemptionsListExemptionsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsListExemptionsVariables = {
  headers?: ExemptionsListExemptionsHeaders
  queryParams: ExemptionsListExemptionsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Exemptions
 */
export const fetchExemptionsListExemptions = (variables: ExemptionsListExemptionsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ExemptionsListExemptionsResponseBody,
    ExemptionsListExemptionsError,
    undefined,
    ExemptionsListExemptionsHeaders,
    ExemptionsListExemptionsQueryParams,
    {}
  >({ url: '/api/v2/exemptions', method: 'get', ...variables, signal })

/**
 * List a collection of Exemptions
 */
export const useExemptionsListExemptions = <TData = Schemas.ExemptionsListExemptionsResponseBody>(
  variables: ExemptionsListExemptionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ExemptionsListExemptionsResponseBody, ExemptionsListExemptionsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ExemptionsListExemptionsResponseBody, ExemptionsListExemptionsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/exemptions', operationId: 'exemptionsListExemptions', variables }),
    queryFn: ({ signal }) => fetchExemptionsListExemptions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ExemptionsCreateExemptionQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * ID of the Harness Organization to which the exemption applies. Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /**
   * ID of the Harness Project to which the exemption applies. You must also specify "orgId". Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsCreateExemptionHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Cumque hic harum.
   */
  ['X-Api-Key']?: string
}

export type ExemptionsCreateExemptionError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsCreateExemptionVariables = {
  body: Schemas.CreateExemptionRequestBody
  headers?: ExemptionsCreateExemptionHeaders
  queryParams: ExemptionsCreateExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Exemption
 */
export const fetchExemptionsCreateExemption = (variables: ExemptionsCreateExemptionVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ExemptionsCreateExemptionError,
    Schemas.CreateExemptionRequestBody,
    ExemptionsCreateExemptionHeaders,
    ExemptionsCreateExemptionQueryParams,
    {}
  >({ url: '/api/v2/exemptions', method: 'post', ...variables, signal })

/**
 * Create a new Exemption
 */
export const useExemptionsCreateExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      ExemptionsCreateExemptionError,
      ExemptionsCreateExemptionVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ExemptionsCreateExemptionError,
    ExemptionsCreateExemptionVariables
  >({
    mutationFn: (variables: ExemptionsCreateExemptionVariables) =>
      fetchExemptionsCreateExemption({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ExemptionsDeleteExemptionPathParams = {
  /**
   * The ID of the Exemption to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsDeleteExemptionQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId?: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId?: string
}

export type ExemptionsDeleteExemptionError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsDeleteExemptionVariables = {
  pathParams: ExemptionsDeleteExemptionPathParams
  queryParams: ExemptionsDeleteExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Exemption
 */
export const fetchExemptionsDeleteExemption = (variables: ExemptionsDeleteExemptionVariables, signal?: AbortSignal) =>
  stoFetch<
    undefined,
    ExemptionsDeleteExemptionError,
    undefined,
    {},
    ExemptionsDeleteExemptionQueryParams,
    ExemptionsDeleteExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'delete', ...variables, signal })

/**
 * Delete an existing Exemption
 */
export const useExemptionsDeleteExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, ExemptionsDeleteExemptionError, ExemptionsDeleteExemptionVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, ExemptionsDeleteExemptionError, ExemptionsDeleteExemptionVariables>({
    mutationFn: (variables: ExemptionsDeleteExemptionVariables) =>
      fetchExemptionsDeleteExemption({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ExemptionsFindExemptionByIdPathParams = {
  /**
   * The ID of the Exemption to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsFindExemptionByIdQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ExemptionsFindExemptionByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Quia rerum nihil repudiandae qui.
   */
  ['X-Api-Key']?: string
}

export type ExemptionsFindExemptionByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsFindExemptionByIdVariables = {
  headers?: ExemptionsFindExemptionByIdHeaders
  pathParams: ExemptionsFindExemptionByIdPathParams
  queryParams: ExemptionsFindExemptionByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Exemption by ID
 */
export const fetchExemptionsFindExemptionById = (
  variables: ExemptionsFindExemptionByIdVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsFindExemptionByIdError,
    undefined,
    ExemptionsFindExemptionByIdHeaders,
    ExemptionsFindExemptionByIdQueryParams,
    ExemptionsFindExemptionByIdPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'get', ...variables, signal })

/**
 * Find Exemption by ID
 */
export const useExemptionsFindExemptionById = <TData = Schemas.Exemption>(
  variables: ExemptionsFindExemptionByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Exemption, ExemptionsFindExemptionByIdError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Exemption, ExemptionsFindExemptionByIdError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/exemptions/{id}', operationId: 'exemptionsFindExemptionById', variables }),
    queryFn: ({ signal }) => fetchExemptionsFindExemptionById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ExemptionsUpdateExemptionPathParams = {
  /**
   * The ID of the Exemption to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsUpdateExemptionQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * ID of the Harness Organization to which the exemption applies. Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /**
   * ID of the Harness Project to which the exemption applies. You must also specify "orgId". Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsUpdateExemptionHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Optio et vel et.
   */
  ['X-Api-Key']?: string
}

export type ExemptionsUpdateExemptionError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsUpdateExemptionVariables = {
  body: Schemas.UpdateExemptionRequestBody
  headers?: ExemptionsUpdateExemptionHeaders
  pathParams: ExemptionsUpdateExemptionPathParams
  queryParams: ExemptionsUpdateExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Exemption
 */
export const fetchExemptionsUpdateExemption = (variables: ExemptionsUpdateExemptionVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsUpdateExemptionError,
    Schemas.UpdateExemptionRequestBody,
    ExemptionsUpdateExemptionHeaders,
    ExemptionsUpdateExemptionQueryParams,
    ExemptionsUpdateExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'put', ...variables, signal })

/**
 * Update an existing Exemption
 */
export const useExemptionsUpdateExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Exemption,
      ExemptionsUpdateExemptionError,
      ExemptionsUpdateExemptionVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Exemption, ExemptionsUpdateExemptionError, ExemptionsUpdateExemptionVariables>({
    mutationFn: (variables: ExemptionsUpdateExemptionVariables) =>
      fetchExemptionsUpdateExemption({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ExemptionsApproveExemptionPathParams = {
  /**
   * The ID of the Exemption to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
  /**
   * The approval action to take on the Exemption
   *
   * @example approve
   */
  action: 'approve' | 'reject'
}

export type ExemptionsApproveExemptionQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsApproveExemptionHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Ex voluptatem sunt sunt libero.
   */
  ['X-Api-Key']?: string
}

export type ExemptionsApproveExemptionError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsApproveExemptionVariables = {
  body: Schemas.ApproveExemptionRequestBody
  headers?: ExemptionsApproveExemptionHeaders
  pathParams: ExemptionsApproveExemptionPathParams
  queryParams: ExemptionsApproveExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Approve/reject an existing Exemption
 */
export const fetchExemptionsApproveExemption = (variables: ExemptionsApproveExemptionVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsApproveExemptionError,
    Schemas.ApproveExemptionRequestBody,
    ExemptionsApproveExemptionHeaders,
    ExemptionsApproveExemptionQueryParams,
    ExemptionsApproveExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}/{action}', method: 'put', ...variables, signal })

/**
 * Approve/reject an existing Exemption
 */
export const useExemptionsApproveExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Exemption,
      ExemptionsApproveExemptionError,
      ExemptionsApproveExemptionVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.Exemption,
    ExemptionsApproveExemptionError,
    ExemptionsApproveExemptionVariables
  >({
    mutationFn: (variables: ExemptionsApproveExemptionVariables) =>
      fetchExemptionsApproveExemption({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type FrontendExecutionForRepoQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * @example Suscipit et minima vel at rerum totam.
   */
  gitUrl: string
  /**
   * @example 4279488893516400600
   * @format int64
   */
  prNumber?: number
}

export type FrontendExecutionForRepoError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendExecutionForRepoVariables = {
  queryParams: FrontendExecutionForRepoQueryParams
} & StoContext['fetcherOptions']

export const fetchFrontendExecutionForRepo = (variables: FrontendExecutionForRepoVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendExecutionForRepoResponseBody,
    FrontendExecutionForRepoError,
    undefined,
    {},
    FrontendExecutionForRepoQueryParams,
    {}
  >({ url: '/api/v2/frontend/execution-for-repo', method: 'get', ...variables, signal })

export const useFrontendExecutionForRepo = <TData = Schemas.FrontendExecutionForRepoResponseBody>(
  variables: FrontendExecutionForRepoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendExecutionForRepoResponseBody, FrontendExecutionForRepoError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendExecutionForRepoResponseBody, FrontendExecutionForRepoError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/execution-for-repo',
      operationId: 'frontendExecutionForRepo',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendExecutionForRepo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendExpiringExemptionsPathParams = {
  /**
   * Harness pipeline execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId: string
}

export type FrontendExpiringExemptionsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Number of days of Baseline Issue counts to return
   *
   * @default 7
   * @example 4820
   * @format int64
   * @maximum 9999
   * @minimum 1
   */
  days?: number
}

export type FrontendExpiringExemptionsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendExpiringExemptionsVariables = {
  pathParams: FrontendExpiringExemptionsPathParams
  queryParams: FrontendExpiringExemptionsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns issue summaries that are going to expire
 */
export const fetchFrontendExpiringExemptions = (variables: FrontendExpiringExemptionsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendExpiringExemptionsResponseBody,
    FrontendExpiringExemptionsError,
    undefined,
    {},
    FrontendExpiringExemptionsQueryParams,
    FrontendExpiringExemptionsPathParams
  >({ url: '/api/v2/frontend/expiring-exemptions/{executionId}', method: 'get', ...variables, signal })

/**
 * Returns issue summaries that are going to expire
 */
export const useFrontendExpiringExemptions = <TData = Schemas.FrontendExpiringExemptionsResponseBody>(
  variables: FrontendExpiringExemptionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendExpiringExemptionsResponseBody, FrontendExpiringExemptionsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendExpiringExemptionsResponseBody, FrontendExpiringExemptionsError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/expiring-exemptions/{executionId}',
      operationId: 'frontendExpiringExemptions',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendExpiringExemptions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendExecutionIssueCountsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Comma-separated list of Harness Execution IDs for which to count Security Issues
   *
   * @example abcdef1234567890ghijkl,mnopqr0987654321stuvwx
   * @pattern [\dA-Za-z_-]{22}(,[\dA-Za-z_-]{22})*
   */
  executionIds: string
}

export type FrontendExecutionIssueCountsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendExecutionIssueCountsResponse = {
  [key: string]: Schemas.IssueCounts
}

export type FrontendExecutionIssueCountsVariables = {
  queryParams: FrontendExecutionIssueCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const fetchFrontendExecutionIssueCounts = (
  variables: FrontendExecutionIssueCountsVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    FrontendExecutionIssueCountsResponse,
    FrontendExecutionIssueCountsError,
    undefined,
    {},
    FrontendExecutionIssueCountsQueryParams,
    {}
  >({ url: '/api/v2/frontend/issue-counts', method: 'get', ...variables, signal })

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const useFrontendExecutionIssueCounts = <TData = FrontendExecutionIssueCountsResponse>(
  variables: FrontendExecutionIssueCountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<FrontendExecutionIssueCountsResponse, FrontendExecutionIssueCountsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<FrontendExecutionIssueCountsResponse, FrontendExecutionIssueCountsError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/issue-counts',
      operationId: 'frontendExecutionIssueCounts',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendExecutionIssueCounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendIssueForExemptionPathParams = {
  /**
   * ID of Security Test Exemption
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  exemptionId: string
}

export type FrontendIssueForExemptionQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @maximum 100
   * @minimum 1
   */
  pageSize?: number
}

export type FrontendIssueForExemptionError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendIssueForExemptionVariables = {
  pathParams: FrontendIssueForExemptionPathParams
  queryParams: FrontendIssueForExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns a specific issue exemption
 */
export const fetchFrontendIssueForExemption = (variables: FrontendIssueForExemptionVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendIssueForExemptionResponseBody,
    FrontendIssueForExemptionError,
    undefined,
    {},
    FrontendIssueForExemptionQueryParams,
    FrontendIssueForExemptionPathParams
  >({ url: '/api/v2/frontend/issue-exemption/{exemptionId}', method: 'get', ...variables, signal })

/**
 * Returns a specific issue exemption
 */
export const useFrontendIssueForExemption = <TData = Schemas.FrontendIssueForExemptionResponseBody>(
  variables: FrontendIssueForExemptionVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendIssueForExemptionResponseBody, FrontendIssueForExemptionError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendIssueForExemptionResponseBody, FrontendIssueForExemptionError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/issue-exemption/{exemptionId}',
      operationId: 'frontendIssueForExemption',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendIssueForExemption({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendOverviewBaselinesQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type FrontendOverviewBaselinesError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendOverviewBaselinesVariables = {
  queryParams: FrontendOverviewBaselinesQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides baseline execution data needed by the Overview page
 */
export const fetchFrontendOverviewBaselines = (variables: FrontendOverviewBaselinesVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendOverviewBaselinesResponseBody,
    FrontendOverviewBaselinesError,
    undefined,
    {},
    FrontendOverviewBaselinesQueryParams,
    {}
  >({ url: '/api/v2/frontend/overview/baselines', method: 'get', ...variables, signal })

/**
 * Provides baseline execution data needed by the Overview page
 */
export const useFrontendOverviewBaselines = <TData = Schemas.FrontendOverviewBaselinesResponseBody>(
  variables: FrontendOverviewBaselinesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendOverviewBaselinesResponseBody, FrontendOverviewBaselinesError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendOverviewBaselinesResponseBody, FrontendOverviewBaselinesError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/overview/baselines',
      operationId: 'frontendOverviewBaselines',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendOverviewBaselines({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendOverviewHistoricalCountsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Number of days of Baseline Issue counts to return
   *
   * @default 30
   * @example 16
   * @format int64
   * @maximum 90
   * @minimum 1
   */
  days?: number
}

export type FrontendOverviewHistoricalCountsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendOverviewHistoricalCountsVariables = {
  queryParams: FrontendOverviewHistoricalCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides historical issue data needed by the Overview page
 */
export const fetchFrontendOverviewHistoricalCounts = (
  variables: FrontendOverviewHistoricalCountsVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.FrontendOverviewHistoricalCountsResponseBody,
    FrontendOverviewHistoricalCountsError,
    undefined,
    {},
    FrontendOverviewHistoricalCountsQueryParams,
    {}
  >({ url: '/api/v2/frontend/overview/historical-counts', method: 'get', ...variables, signal })

/**
 * Provides historical issue data needed by the Overview page
 */
export const useFrontendOverviewHistoricalCounts = <TData = Schemas.FrontendOverviewHistoricalCountsResponseBody>(
  variables: FrontendOverviewHistoricalCountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FrontendOverviewHistoricalCountsResponseBody,
      FrontendOverviewHistoricalCountsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<
    Schemas.FrontendOverviewHistoricalCountsResponseBody,
    FrontendOverviewHistoricalCountsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/overview/historical-counts',
      operationId: 'frontendOverviewHistoricalCounts',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendOverviewHistoricalCounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendPipelineSecurityIssuesQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Harness Execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  pageExisting?: number
  /**
   * Number of results per page
   *
   * @default 50
   * @example 50
   * @format int64
   * @maximum 100
   * @minimum 1
   */
  pageSizeExisting?: number
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  pageNew?: number
  /**
   * Number of results per page
   *
   * @default 50
   * @example 50
   * @format int64
   * @maximum 100
   * @minimum 1
   */
  pageSizeNew?: number
  /**
   * @example stage1,stage2
   * @pattern ^([a-zA-Z0-9_]+)(,[a-zA-Z0-9_]+)*$
   */
  stages?: string
  /**
   * @example stageId.step1id,stageId.step2Id
   * @pattern ^([a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)(,[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)*$
   */
  steps?: string
  /**
   * @example target1111111111111111,abcdef1234567890abcdef
   * @pattern ^([a-zA-Z0-9_-]{22})(,[a-zA-Z0-9_-]{22})*$
   */
  targetIds?: string
  /**
   * @example repository,container
   * @pattern ^(repository|container|instance|configuration)(,repository|,container|,instance|,configuration)*$
   */
  targetTypes?: string
  /**
   * @example owasp,zap
   * @pattern ^([a-zA-Z0-9_-]+)(,[a-zA-Z0-9_-]+)*$
   */
  productNames?: string
  /**
   * @example Critical,High,Medium
   * @pattern ^(Critical|High|Medium|Low|Info)(,Critical|,High|,Medium|,Low|,Info)*$
   */
  severityCodes?: string
  /**
   * @default true
   * @example true
   */
  includeExempted?: boolean
  /**
   * @example CWE-123
   * @maxLength 256
   */
  search?: string
}

export type FrontendPipelineSecurityIssuesError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendPipelineSecurityIssuesVariables = {
  queryParams: FrontendPipelineSecurityIssuesQueryParams
} & StoContext['fetcherOptions']

/**
 * Provide issue data needed by the PipelineSecurityView
 */
export const fetchFrontendPipelineSecurityIssues = (
  variables: FrontendPipelineSecurityIssuesVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.FrontendPipelineSecurityIssuesResponseBody,
    FrontendPipelineSecurityIssuesError,
    undefined,
    {},
    FrontendPipelineSecurityIssuesQueryParams,
    {}
  >({ url: '/api/v2/frontend/pipeline-security/issues', method: 'get', ...variables, signal })

/**
 * Provide issue data needed by the PipelineSecurityView
 */
export const useFrontendPipelineSecurityIssues = <TData = Schemas.FrontendPipelineSecurityIssuesResponseBody>(
  variables: FrontendPipelineSecurityIssuesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FrontendPipelineSecurityIssuesResponseBody,
      FrontendPipelineSecurityIssuesError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<
    Schemas.FrontendPipelineSecurityIssuesResponseBody,
    FrontendPipelineSecurityIssuesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/pipeline-security/issues',
      operationId: 'frontendPipelineSecurityIssues',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendPipelineSecurityIssues({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendPipelineSecurityStepsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Harness Execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId: string
}

export type FrontendPipelineSecurityStepsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendPipelineSecurityStepsVariables = {
  queryParams: FrontendPipelineSecurityStepsQueryParams
} & StoContext['fetcherOptions']

/**
 * Provide step data needed by the PipelineSecurityView
 */
export const fetchFrontendPipelineSecuritySteps = (
  variables: FrontendPipelineSecurityStepsVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.FrontendPipelineSecurityStepsResponseBody,
    FrontendPipelineSecurityStepsError,
    undefined,
    {},
    FrontendPipelineSecurityStepsQueryParams,
    {}
  >({ url: '/api/v2/frontend/pipeline-security/steps', method: 'get', ...variables, signal })

/**
 * Provide step data needed by the PipelineSecurityView
 */
export const useFrontendPipelineSecuritySteps = <TData = Schemas.FrontendPipelineSecurityStepsResponseBody>(
  variables: FrontendPipelineSecurityStepsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FrontendPipelineSecurityStepsResponseBody,
      FrontendPipelineSecurityStepsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<
    Schemas.FrontendPipelineSecurityStepsResponseBody,
    FrontendPipelineSecurityStepsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/pipeline-security/steps',
      operationId: 'frontendPipelineSecuritySteps',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendPipelineSecuritySteps({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendSecurityReviewQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type FrontendSecurityReviewError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendSecurityReviewVariables = {
  queryParams: FrontendSecurityReviewQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides data needed by the Security Review page
 */
export const fetchFrontendSecurityReview = (variables: FrontendSecurityReviewVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendSecurityReviewResponseBody,
    FrontendSecurityReviewError,
    undefined,
    {},
    FrontendSecurityReviewQueryParams,
    {}
  >({ url: '/api/v2/frontend/security-review', method: 'get', ...variables, signal })

/**
 * Provides data needed by the Security Review page
 */
export const useFrontendSecurityReview = <TData = Schemas.FrontendSecurityReviewResponseBody>(
  variables: FrontendSecurityReviewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendSecurityReviewResponseBody, FrontendSecurityReviewError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendSecurityReviewResponseBody, FrontendSecurityReviewError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/frontend/security-review',
      operationId: 'frontendSecurityReview',
      variables,
    }),
    queryFn: ({ signal }) => fetchFrontendSecurityReview({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type FrontendTestTargetsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @maximum 100
   * @minimum 1
   */
  pageSize?: number
  /**
   * @example The Target
   * @maxLength 128
   */
  search?: string
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId?: string
}

export type FrontendTestTargetsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendTestTargetsVariables = {
  queryParams: FrontendTestTargetsQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides data needed by the Test Targets page
 */
export const fetchFrontendTestTargets = (variables: FrontendTestTargetsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.FrontendTestTargetsResponseBody,
    FrontendTestTargetsError,
    undefined,
    {},
    FrontendTestTargetsQueryParams,
    {}
  >({ url: '/api/v2/frontend/test-targets', method: 'get', ...variables, signal })

/**
 * Provides data needed by the Test Targets page
 */
export const useFrontendTestTargets = <TData = Schemas.FrontendTestTargetsResponseBody>(
  variables: FrontendTestTargetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendTestTargetsResponseBody, FrontendTestTargetsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendTestTargetsResponseBody, FrontendTestTargetsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/frontend/test-targets', operationId: 'frontendTestTargets', variables }),
    queryFn: ({ signal }) => fetchFrontendTestTargets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type IssuesListIssuesQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /**
   * Issue product ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  productId?: string
  /**
   * Compression/deduplication key
   *
   * @example json-schema@0.2.3
   * @maxLength 512
   */
  key?: string
  /**
   * @example false
   */
  excludeOccurrences?: boolean
}

export type IssuesListIssuesHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Dicta incidunt vel voluptatem laboriosam non.
   */
  ['X-Api-Key']?: string
}

export type IssuesListIssuesError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesListIssuesVariables = {
  headers?: IssuesListIssuesHeaders
  queryParams: IssuesListIssuesQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Security Issues
 */
export const fetchIssuesListIssues = (variables: IssuesListIssuesVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.IssuesListIssuesResponseBody,
    IssuesListIssuesError,
    undefined,
    IssuesListIssuesHeaders,
    IssuesListIssuesQueryParams,
    {}
  >({ url: '/api/v2/issues', method: 'get', ...variables, signal })

/**
 * List a collection of Security Issues
 */
export const useIssuesListIssues = <TData = Schemas.IssuesListIssuesResponseBody>(
  variables: IssuesListIssuesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.IssuesListIssuesResponseBody, IssuesListIssuesError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.IssuesListIssuesResponseBody, IssuesListIssuesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/issues', operationId: 'issuesListIssues', variables }),
    queryFn: ({ signal }) => fetchIssuesListIssues({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type IssuesCreateIssueQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Indicates the Occurrences have already been normalized
   *
   * @example false
   */
  normalized?: boolean
}

export type IssuesCreateIssueHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Ullam rerum aut et.
   */
  ['X-Api-Key']?: string
}

export type IssuesCreateIssueError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesCreateIssueVariables = {
  body: Schemas.CreateIssueRequestBody
  headers?: IssuesCreateIssueHeaders
  queryParams: IssuesCreateIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Security Issue
 */
export const fetchIssuesCreateIssue = (variables: IssuesCreateIssueVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    IssuesCreateIssueError,
    Schemas.CreateIssueRequestBody,
    IssuesCreateIssueHeaders,
    IssuesCreateIssueQueryParams,
    {}
  >({ url: '/api/v2/issues', method: 'post', ...variables, signal })

/**
 * Create a new Security Issue
 */
export const useIssuesCreateIssue = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      IssuesCreateIssueError,
      IssuesCreateIssueVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    IssuesCreateIssueError,
    IssuesCreateIssueVariables
  >({
    mutationFn: (variables: IssuesCreateIssueVariables) => fetchIssuesCreateIssue({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type IssuesDeleteIssuePathParams = {
  /**
   * The ID of the Security Issue to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type IssuesDeleteIssueQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type IssuesDeleteIssueError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesDeleteIssueVariables = {
  pathParams: IssuesDeleteIssuePathParams
  queryParams: IssuesDeleteIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Security Issue
 */
export const fetchIssuesDeleteIssue = (variables: IssuesDeleteIssueVariables, signal?: AbortSignal) =>
  stoFetch<undefined, IssuesDeleteIssueError, undefined, {}, IssuesDeleteIssueQueryParams, IssuesDeleteIssuePathParams>(
    { url: '/api/v2/issues/{id}', method: 'delete', ...variables, signal },
  )

/**
 * Delete an existing Security Issue
 */
export const useIssuesDeleteIssue = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, IssuesDeleteIssueError, IssuesDeleteIssueVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, IssuesDeleteIssueError, IssuesDeleteIssueVariables>({
    mutationFn: (variables: IssuesDeleteIssueVariables) => fetchIssuesDeleteIssue({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type IssuesFindIssueByIdPathParams = {
  /**
   * The ID of the Security Issue to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type IssuesFindIssueByIdQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId?: string
}

export type IssuesFindIssueByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Id et voluptatem doloribus.
   */
  ['X-Api-Key']?: string
}

export type IssuesFindIssueByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesFindIssueByIdVariables = {
  headers?: IssuesFindIssueByIdHeaders
  pathParams: IssuesFindIssueByIdPathParams
  queryParams: IssuesFindIssueByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Security Issue by ID
 */
export const fetchIssuesFindIssueById = (variables: IssuesFindIssueByIdVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Issue,
    IssuesFindIssueByIdError,
    undefined,
    IssuesFindIssueByIdHeaders,
    IssuesFindIssueByIdQueryParams,
    IssuesFindIssueByIdPathParams
  >({ url: '/api/v2/issues/{id}', method: 'get', ...variables, signal })

/**
 * Find Security Issue by ID
 */
export const useIssuesFindIssueById = <TData = Schemas.Issue>(
  variables: IssuesFindIssueByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Issue, IssuesFindIssueByIdError, TData>, 'queryKey' | 'queryFn'>,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Issue, IssuesFindIssueByIdError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/issues/{id}', operationId: 'issuesFindIssueById', variables }),
    queryFn: ({ signal }) => fetchIssuesFindIssueById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type IssuesUpdateIssuePathParams = {
  /**
   * The ID of the Security Issue to update
   *
   * @example In officia recusandae.
   */
  id: string
}

export type IssuesUpdateIssueQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type IssuesUpdateIssueHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example In modi veritatis tenetur voluptatibus qui illum.
   */
  ['X-Api-Key']?: string
}

export type IssuesUpdateIssueError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesUpdateIssueVariables = {
  body: Schemas.UpdateIssueRequestBody
  headers?: IssuesUpdateIssueHeaders
  pathParams: IssuesUpdateIssuePathParams
  queryParams: IssuesUpdateIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Security Issue
 */
export const fetchIssuesUpdateIssue = (variables: IssuesUpdateIssueVariables, signal?: AbortSignal) =>
  stoFetch<
    undefined,
    IssuesUpdateIssueError,
    Schemas.UpdateIssueRequestBody,
    IssuesUpdateIssueHeaders,
    IssuesUpdateIssueQueryParams,
    IssuesUpdateIssuePathParams
  >({ url: '/api/v2/issues/{id}', method: 'put', ...variables, signal })

/**
 * Update an existing Security Issue
 */
export const useIssuesUpdateIssue = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, IssuesUpdateIssueError, IssuesUpdateIssueVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, IssuesUpdateIssueError, IssuesUpdateIssueVariables>({
    mutationFn: (variables: IssuesUpdateIssueVariables) => fetchIssuesUpdateIssue({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type IssuesIssuesAugmentRemediationPathParams = {
  /**
   * The ID of the Security Issue to augment
   *
   * @example 1234567890abcdefghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type IssuesIssuesAugmentRemediationQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type IssuesIssuesAugmentRemediationHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Est dolorum animi qui rem tenetur.
   */
  ['X-Api-Key']?: string
}

export type IssuesIssuesAugmentRemediationError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesIssuesAugmentRemediationVariables = {
  body: Schemas.IssuesAugmentRemediationRequestBody
  headers?: IssuesIssuesAugmentRemediationHeaders
  pathParams: IssuesIssuesAugmentRemediationPathParams
  queryParams: IssuesIssuesAugmentRemediationQueryParams
} & StoContext['fetcherOptions']

/**
 * Use AI to augment the remediation steps for this Security Issue
 */
export const fetchIssuesIssuesAugmentRemediation = (
  variables: IssuesIssuesAugmentRemediationVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.IssuesIssuesAugmentRemediationResponseBody,
    IssuesIssuesAugmentRemediationError,
    Schemas.IssuesAugmentRemediationRequestBody,
    IssuesIssuesAugmentRemediationHeaders,
    IssuesIssuesAugmentRemediationQueryParams,
    IssuesIssuesAugmentRemediationPathParams
  >({ url: '/api/v2/issues/{id}/augment-remediation', method: 'post', ...variables, signal })

/**
 * Use AI to augment the remediation steps for this Security Issue
 */
export const useIssuesIssuesAugmentRemediation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.IssuesIssuesAugmentRemediationResponseBody,
      IssuesIssuesAugmentRemediationError,
      IssuesIssuesAugmentRemediationVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.IssuesIssuesAugmentRemediationResponseBody,
    IssuesIssuesAugmentRemediationError,
    IssuesIssuesAugmentRemediationVariables
  >({
    mutationFn: (variables: IssuesIssuesAugmentRemediationVariables) =>
      fetchIssuesIssuesAugmentRemediation({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ProductsListProductsQueryParams = {
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /**
   * Resource name
   *
   * @example NodeGoat
   */
  name?: string
}

export type ProductsListProductsHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Repudiandae aut.
   */
  ['X-Api-Key']?: string
}

export type ProductsListProductsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ProductsListProductsVariables = {
  headers?: ProductsListProductsHeaders
  queryParams?: ProductsListProductsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Scan Tools
 */
export const fetchProductsListProducts = (variables: ProductsListProductsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ProductsListProductsResponseBody,
    ProductsListProductsError,
    undefined,
    ProductsListProductsHeaders,
    ProductsListProductsQueryParams,
    {}
  >({ url: '/api/v2/products', method: 'get', ...variables, signal })

/**
 * List a collection of Scan Tools
 */
export const useProductsListProducts = <TData = Schemas.ProductsListProductsResponseBody>(
  variables: ProductsListProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ProductsListProductsResponseBody, ProductsListProductsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ProductsListProductsResponseBody, ProductsListProductsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/products', operationId: 'productsListProducts', variables }),
    queryFn: ({ signal }) => fetchProductsListProducts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ProductsFindProductByIdPathParams = {
  /**
   * The ID of the Scan Tool to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ProductsFindProductByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Et officiis libero a.
   */
  ['X-Api-Key']?: string
}

export type ProductsFindProductByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ProductsFindProductByIdVariables = {
  headers?: ProductsFindProductByIdHeaders
  pathParams: ProductsFindProductByIdPathParams
} & StoContext['fetcherOptions']

/**
 * Find Scan Tool by ID
 */
export const fetchProductsFindProductById = (variables: ProductsFindProductByIdVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Product,
    ProductsFindProductByIdError,
    undefined,
    ProductsFindProductByIdHeaders,
    {},
    ProductsFindProductByIdPathParams
  >({ url: '/api/v2/products/{id}', method: 'get', ...variables, signal })

/**
 * Find Scan Tool by ID
 */
export const useProductsFindProductById = <TData = Schemas.Product>(
  variables: ProductsFindProductByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Product, ProductsFindProductByIdError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Product, ProductsFindProductByIdError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/products/{id}', operationId: 'productsFindProductById', variables }),
    queryFn: ({ signal }) => fetchProductsFindProductById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ReferenceIdentifiersGetByReferenceIdPathParams = {
  /**
   * @example CWE-123
   */
  refId: string
}

export type ReferenceIdentifiersGetByReferenceIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Molestias eos officia.
   */
  ['X-Api-Key']?: string
}

export type ReferenceIdentifiersGetByReferenceIdError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
>

export type ReferenceIdentifiersGetByReferenceIdVariables = {
  headers?: ReferenceIdentifiersGetByReferenceIdHeaders
  pathParams: ReferenceIdentifiersGetByReferenceIdPathParams
} & StoContext['fetcherOptions']

/**
 * Reference Identifiers Lookup
 */
export const fetchReferenceIdentifiersGetByReferenceId = (
  variables: ReferenceIdentifiersGetByReferenceIdVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.GetByReferenceIDResponseBody,
    ReferenceIdentifiersGetByReferenceIdError,
    undefined,
    ReferenceIdentifiersGetByReferenceIdHeaders,
    {},
    ReferenceIdentifiersGetByReferenceIdPathParams
  >({ url: '/api/v2/reference-identifiers/{refId}', method: 'get', ...variables, signal })

/**
 * Reference Identifiers Lookup
 */
export const useReferenceIdentifiersGetByReferenceId = <TData = Schemas.GetByReferenceIDResponseBody>(
  variables: ReferenceIdentifiersGetByReferenceIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GetByReferenceIDResponseBody, ReferenceIdentifiersGetByReferenceIdError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.GetByReferenceIDResponseBody, ReferenceIdentifiersGetByReferenceIdError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/reference-identifiers/{refId}',
      operationId: 'referenceIdentifiersGetByReferenceId',
      variables,
    }),
    queryFn: ({ signal }) => fetchReferenceIdentifiersGetByReferenceId({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ScansListScansQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /**
   * Harness Execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId?: string
}

export type ScansListScansHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Maiores et voluptatem laboriosam modi voluptates aut.
   */
  ['X-Api-Key']?: string
}

export type ScansListScansError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansListScansVariables = {
  headers?: ScansListScansHeaders
  queryParams: ScansListScansQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Security Test Scans
 */
export const fetchScansListScans = (variables: ScansListScansVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ScansListScansResponseBody,
    ScansListScansError,
    undefined,
    ScansListScansHeaders,
    ScansListScansQueryParams,
    {}
  >({ url: '/api/v2/scans', method: 'get', ...variables, signal })

/**
 * List a collection of Security Test Scans
 */
export const useScansListScans = <TData = Schemas.ScansListScansResponseBody>(
  variables: ScansListScansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ScansListScansResponseBody, ScansListScansError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ScansListScansResponseBody, ScansListScansError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/scans', operationId: 'scansListScans', variables }),
    queryFn: ({ signal }) => fetchScansListScans({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ScansCreateScanQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansCreateScanHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Deleniti et.
   */
  ['X-Api-Key']?: string
  /**
   * Harness User ID
   *
   * @example abcdef1234567890ghijkl
   */
  ['X-Harness-User-Id']?: string
}

export type ScansCreateScanError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansCreateScanVariables = {
  body: Schemas.CreateScanRequestBody
  headers?: ScansCreateScanHeaders
  queryParams: ScansCreateScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Security Test Scan
 */
export const fetchScansCreateScan = (variables: ScansCreateScanVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ScansCreateScanError,
    Schemas.CreateScanRequestBody,
    ScansCreateScanHeaders,
    ScansCreateScanQueryParams,
    {}
  >({ url: '/api/v2/scans', method: 'post', ...variables, signal })

/**
 * Create a new Security Test Scan
 */
export const useScansCreateScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      ScansCreateScanError,
      ScansCreateScanVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ScansCreateScanError,
    ScansCreateScanVariables
  >({
    mutationFn: (variables: ScansCreateScanVariables) => fetchScansCreateScan({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ScansDeleteScanPathParams = {
  /**
   * The ID of the Security Test Scan to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansDeleteScanQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansDeleteScanError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansDeleteScanVariables = {
  pathParams: ScansDeleteScanPathParams
  queryParams: ScansDeleteScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Security Test Scan
 */
export const fetchScansDeleteScan = (variables: ScansDeleteScanVariables, signal?: AbortSignal) =>
  stoFetch<undefined, ScansDeleteScanError, undefined, {}, ScansDeleteScanQueryParams, ScansDeleteScanPathParams>({
    url: '/api/v2/scans/{id}',
    method: 'delete',
    ...variables,
    signal,
  })

/**
 * Delete an existing Security Test Scan
 */
export const useScansDeleteScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, ScansDeleteScanError, ScansDeleteScanVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, ScansDeleteScanError, ScansDeleteScanVariables>({
    mutationFn: (variables: ScansDeleteScanVariables) => fetchScansDeleteScan({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ScansFindScanByIdPathParams = {
  /**
   * The ID of the Security Test Scan to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansFindScanByIdQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansFindScanByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Ad consequatur quo ex eos.
   */
  ['X-Api-Key']?: string
}

export type ScansFindScanByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansFindScanByIdVariables = {
  headers?: ScansFindScanByIdHeaders
  pathParams: ScansFindScanByIdPathParams
  queryParams: ScansFindScanByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Security Test Scan by ID
 */
export const fetchScansFindScanById = (variables: ScansFindScanByIdVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Scan,
    ScansFindScanByIdError,
    undefined,
    ScansFindScanByIdHeaders,
    ScansFindScanByIdQueryParams,
    ScansFindScanByIdPathParams
  >({ url: '/api/v2/scans/{id}', method: 'get', ...variables, signal })

/**
 * Find Security Test Scan by ID
 */
export const useScansFindScanById = <TData = Schemas.Scan>(
  variables: ScansFindScanByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Scan, ScansFindScanByIdError, TData>, 'queryKey' | 'queryFn'>,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Scan, ScansFindScanByIdError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/scans/{id}', operationId: 'scansFindScanById', variables }),
    queryFn: ({ signal }) => fetchScansFindScanById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ScansUpdateScanPathParams = {
  /**
   * The ID of the Security Test Scan to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansUpdateScanQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansUpdateScanHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Deserunt dolorum nam.
   */
  ['X-Api-Key']?: string
}

export type ScansUpdateScanError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansUpdateScanVariables = {
  body: Schemas.UpdateScanRequestBody
  headers?: ScansUpdateScanHeaders
  pathParams: ScansUpdateScanPathParams
  queryParams: ScansUpdateScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Security Test Scan
 */
export const fetchScansUpdateScan = (variables: ScansUpdateScanVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Scan,
    ScansUpdateScanError,
    Schemas.UpdateScanRequestBody,
    ScansUpdateScanHeaders,
    ScansUpdateScanQueryParams,
    ScansUpdateScanPathParams
  >({ url: '/api/v2/scans/{id}', method: 'put', ...variables, signal })

/**
 * Update an existing Security Test Scan
 */
export const useScansUpdateScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Scan, ScansUpdateScanError, ScansUpdateScanVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Scan, ScansUpdateScanError, ScansUpdateScanVariables>({
    mutationFn: (variables: ScansUpdateScanVariables) => fetchScansUpdateScan({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type ScansScanIssuePathParams = {
  /**
   * The ID of the Security Test Scan
   *
   * @example Velit ut est quasi voluptatem.
   */
  id: string
  /**
   * The ID of the Security Test Issue
   *
   * @example Cupiditate iusto dolor.
   */
  issueId: string
}

export type ScansScanIssueQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
}

export type ScansScanIssueHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Id eos vitae magnam aliquid iste corporis.
   */
  ['X-Api-Key']?: string
}

export type ScansScanIssueError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansScanIssueVariables = {
  headers?: ScansScanIssueHeaders
  pathParams: ScansScanIssuePathParams
  queryParams: ScansScanIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns a scan specific issue
 */
export const fetchScansScanIssue = (variables: ScansScanIssueVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ScansScanIssueResponseBody,
    ScansScanIssueError,
    undefined,
    ScansScanIssueHeaders,
    ScansScanIssueQueryParams,
    ScansScanIssuePathParams
  >({ url: '/api/v2/scans/{id}/issue/{issueId}', method: 'get', ...variables, signal })

/**
 * Returns a scan specific issue
 */
export const useScansScanIssue = <TData = Schemas.ScansScanIssueResponseBody>(
  variables: ScansScanIssueVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ScansScanIssueResponseBody, ScansScanIssueError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ScansScanIssueResponseBody, ScansScanIssueError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/scans/{id}/issue/{issueId}', operationId: 'scansScanIssue', variables }),
    queryFn: ({ signal }) => fetchScansScanIssue({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ScansScanIssuesPathParams = {
  /**
   * The Scan ID
   *
   * @example abcdefghijkl1234567890
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansScanIssuesQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansScanIssuesHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Molestiae vero.
   */
  ['X-Api-Key']?: string
}

export type ScansScanIssuesError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansScanIssuesVariables = {
  headers?: ScansScanIssuesHeaders
  pathParams: ScansScanIssuesPathParams
  queryParams: ScansScanIssuesQueryParams
} & StoContext['fetcherOptions']

/**
 * List Issues by Scan ID
 */
export const fetchScansScanIssues = (variables: ScansScanIssuesVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ScansScanIssuesResponseBody,
    ScansScanIssuesError,
    undefined,
    ScansScanIssuesHeaders,
    ScansScanIssuesQueryParams,
    ScansScanIssuesPathParams
  >({ url: '/api/v2/scans/{id}/issues', method: 'get', ...variables, signal })

/**
 * List Issues by Scan ID
 */
export const useScansScanIssues = <TData = Schemas.ScansScanIssuesResponseBody>(
  variables: ScansScanIssuesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ScansScanIssuesResponseBody, ScansScanIssuesError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ScansScanIssuesResponseBody, ScansScanIssuesError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/scans/{id}/issues', operationId: 'scansScanIssues', variables }),
    queryFn: ({ signal }) => fetchScansScanIssues({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ScansScanIssueCountsPathParams = {
  /**
   * The ID of the Security Test Scan for which to count issues
   *
   * @example Et in.
   */
  id: string
}

export type ScansScanIssueCountsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type ScansScanIssueCountsHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Quidem ullam ducimus.
   */
  ['X-Api-Key']?: string
}

export type ScansScanIssueCountsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansScanIssueCountsVariables = {
  headers?: ScansScanIssueCountsHeaders
  pathParams: ScansScanIssueCountsPathParams
  queryParams: ScansScanIssueCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for a Security Test Scan
 */
export const fetchScansScanIssueCounts = (variables: ScansScanIssueCountsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ScansScanIssueCountsResponseBody,
    ScansScanIssueCountsError,
    undefined,
    ScansScanIssueCountsHeaders,
    ScansScanIssueCountsQueryParams,
    ScansScanIssueCountsPathParams
  >({ url: '/api/v2/scans/{id}/issues/counts', method: 'get', ...variables, signal })

/**
 * Returns counts of active Security Issues for a Security Test Scan
 */
export const useScansScanIssueCounts = <TData = Schemas.ScansScanIssueCountsResponseBody>(
  variables: ScansScanIssueCountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ScansScanIssueCountsResponseBody, ScansScanIssueCountsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ScansScanIssueCountsResponseBody, ScansScanIssueCountsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/scans/{id}/issues/counts', operationId: 'scansScanIssueCounts', variables }),
    queryFn: ({ signal }) => fetchScansScanIssueCounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type SSCAFrontendSscaExecutionArtifactSummaryQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type SSCAFrontendSscaExecutionArtifactSummaryError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type SSCAFrontendSscaExecutionArtifactSummaryResponse = Schemas.IssueCountsWithExecutionInfo[]

export type SSCAFrontendSscaExecutionArtifactSummaryVariables = {
  body?: Schemas.SscaExecutionArtifactSummaryRequestBody
  queryParams: SSCAFrontendSscaExecutionArtifactSummaryQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const fetchSSCAFrontendSscaExecutionArtifactSummary = (
  variables: SSCAFrontendSscaExecutionArtifactSummaryVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    SSCAFrontendSscaExecutionArtifactSummaryResponse,
    SSCAFrontendSscaExecutionArtifactSummaryError,
    Schemas.SscaExecutionArtifactSummaryRequestBody,
    {},
    SSCAFrontendSscaExecutionArtifactSummaryQueryParams,
    {}
  >({ url: '/api/v2/ssca-frontend/artifact-summary', method: 'post', ...variables, signal })

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const useSSCAFrontendSscaExecutionArtifactSummary = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      SSCAFrontendSscaExecutionArtifactSummaryResponse,
      SSCAFrontendSscaExecutionArtifactSummaryError,
      SSCAFrontendSscaExecutionArtifactSummaryVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    SSCAFrontendSscaExecutionArtifactSummaryResponse,
    SSCAFrontendSscaExecutionArtifactSummaryError,
    SSCAFrontendSscaExecutionArtifactSummaryVariables
  >({
    mutationFn: (variables: SSCAFrontendSscaExecutionArtifactSummaryVariables) =>
      fetchSSCAFrontendSscaExecutionArtifactSummary({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type SSCAFrontendSscaExecutionSummaryPathParams = {
  /**
   * Harness pipeline execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId: string
}

export type SSCAFrontendSscaExecutionSummaryQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type SSCAFrontendSscaExecutionSummaryError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type SSCAFrontendSscaExecutionSummaryResponse = Schemas.IssueCountsWithExecutionInfo[]

export type SSCAFrontendSscaExecutionSummaryVariables = {
  pathParams: SSCAFrontendSscaExecutionSummaryPathParams
  queryParams: SSCAFrontendSscaExecutionSummaryQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for a specific Pipeline Executions
 */
export const fetchSSCAFrontendSscaExecutionSummary = (
  variables: SSCAFrontendSscaExecutionSummaryVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    SSCAFrontendSscaExecutionSummaryResponse,
    SSCAFrontendSscaExecutionSummaryError,
    undefined,
    {},
    SSCAFrontendSscaExecutionSummaryQueryParams,
    SSCAFrontendSscaExecutionSummaryPathParams
  >({ url: '/api/v2/ssca-frontend/execution-summary/{executionId}', method: 'get', ...variables, signal })

/**
 * Returns counts of active Security Issues for a specific Pipeline Executions
 */
export const useSSCAFrontendSscaExecutionSummary = <TData = SSCAFrontendSscaExecutionSummaryResponse>(
  variables: SSCAFrontendSscaExecutionSummaryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<SSCAFrontendSscaExecutionSummaryResponse, SSCAFrontendSscaExecutionSummaryError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<SSCAFrontendSscaExecutionSummaryResponse, SSCAFrontendSscaExecutionSummaryError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/ssca-frontend/execution-summary/{executionId}',
      operationId: 'sSCAFrontendSscaExecutionSummary',
      variables,
    }),
    queryFn: ({ signal }) => fetchSSCAFrontendSscaExecutionSummary({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type SSCAFrontendSscaExecutionIssueCountsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type SSCAFrontendSscaExecutionIssueCountsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type SSCAFrontendSscaExecutionIssueCountsResponse = {
  [key: string]: {
    [key: string]: {
      [key: string]: Schemas.IssueCountsWithExecutionInfo
    }
  }
}

export type SSCAFrontendSscaExecutionIssueCountsVariables = {
  body?: Schemas.SscaExecutionIssueCountsRequestBody
  queryParams: SSCAFrontendSscaExecutionIssueCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const fetchSSCAFrontendSscaExecutionIssueCounts = (
  variables: SSCAFrontendSscaExecutionIssueCountsVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    SSCAFrontendSscaExecutionIssueCountsResponse,
    SSCAFrontendSscaExecutionIssueCountsError,
    Schemas.SscaExecutionIssueCountsRequestBody,
    {},
    SSCAFrontendSscaExecutionIssueCountsQueryParams,
    {}
  >({ url: '/api/v2/ssca-frontend/issue-counts', method: 'post', ...variables, signal })

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const useSSCAFrontendSscaExecutionIssueCounts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      SSCAFrontendSscaExecutionIssueCountsResponse,
      SSCAFrontendSscaExecutionIssueCountsError,
      SSCAFrontendSscaExecutionIssueCountsVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    SSCAFrontendSscaExecutionIssueCountsResponse,
    SSCAFrontendSscaExecutionIssueCountsError,
    SSCAFrontendSscaExecutionIssueCountsVariables
  >({
    mutationFn: (variables: SSCAFrontendSscaExecutionIssueCountsVariables) =>
      fetchSSCAFrontendSscaExecutionIssueCounts({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type SystemHealthError = Fetcher.ErrorWrapper<{
  status: 500
  payload: Schemas.NotFound
}>

export type SystemHealthVariables = StoContext['fetcherOptions']

/**
 * Check service health
 */
export const fetchSystemHealth = (variables: SystemHealthVariables, signal?: AbortSignal) =>
  stoFetch<undefined, SystemHealthError, undefined, {}, {}, {}>({
    url: '/api/v2/system/health',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Check service health
 */
export const useSystemHealth = <TData = undefined>(
  variables: SystemHealthVariables,
  options?: Omit<reactQuery.UseQueryOptions<undefined, SystemHealthError, TData>, 'queryKey' | 'queryFn'>,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<undefined, SystemHealthError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/system/health', operationId: 'systemHealth', variables }),
    queryFn: ({ signal }) => fetchSystemHealth({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type SystemVersionError = Fetcher.ErrorWrapper<undefined>

export type SystemVersionVariables = StoContext['fetcherOptions']

/**
 * Get service version
 */
export const fetchSystemVersion = (variables: SystemVersionVariables, signal?: AbortSignal) =>
  stoFetch<Schemas.ServiceVersion, SystemVersionError, undefined, {}, {}, {}>({
    url: '/api/v2/system/version',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Get service version
 */
export const useSystemVersion = <TData = Schemas.ServiceVersion>(
  variables: SystemVersionVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.ServiceVersion, SystemVersionError, TData>, 'queryKey' | 'queryFn'>,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ServiceVersion, SystemVersionError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/system/version', operationId: 'systemVersion', variables }),
    queryFn: ({ signal }) => fetchSystemVersion({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type TargetsListTargetsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /**
   * Resource name
   *
   * @example NodeGoat
   */
  name?: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsListTargetsHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Dolor voluptates aliquid.
   */
  ['X-Api-Key']?: string
}

export type TargetsListTargetsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsListTargetsVariables = {
  headers?: TargetsListTargetsHeaders
  queryParams: TargetsListTargetsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Test Targets
 */
export const fetchTargetsListTargets = (variables: TargetsListTargetsVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.TargetsListTargetsResponseBody,
    TargetsListTargetsError,
    undefined,
    TargetsListTargetsHeaders,
    TargetsListTargetsQueryParams,
    {}
  >({ url: '/api/v2/targets', method: 'get', ...variables, signal })

/**
 * List a collection of Test Targets
 */
export const useTargetsListTargets = <TData = Schemas.TargetsListTargetsResponseBody>(
  variables: TargetsListTargetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TargetsListTargetsResponseBody, TargetsListTargetsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TargetsListTargetsResponseBody, TargetsListTargetsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/targets', operationId: 'targetsListTargets', variables }),
    queryFn: ({ signal }) => fetchTargetsListTargets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type TargetsCreateTargetQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsCreateTargetHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Necessitatibus quaerat quam quisquam magnam vitae.
   */
  ['X-Api-Key']?: string
}

export type TargetsCreateTargetError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsCreateTargetVariables = {
  body: Schemas.CreateTargetRequestBody
  headers?: TargetsCreateTargetHeaders
  queryParams: TargetsCreateTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Test Target
 */
export const fetchTargetsCreateTarget = (variables: TargetsCreateTargetVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    TargetsCreateTargetError,
    Schemas.CreateTargetRequestBody,
    TargetsCreateTargetHeaders,
    TargetsCreateTargetQueryParams,
    {}
  >({ url: '/api/v2/targets', method: 'post', ...variables, signal })

/**
 * Create a new Test Target
 */
export const useTargetsCreateTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      TargetsCreateTargetError,
      TargetsCreateTargetVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    TargetsCreateTargetError,
    TargetsCreateTargetVariables
  >({
    mutationFn: (variables: TargetsCreateTargetVariables) =>
      fetchTargetsCreateTarget({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetsDeleteTargetPathParams = {
  /**
   * The ID of the Test Target to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsDeleteTargetQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @maxLength 128
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   */
  projectId: string
}

export type TargetsDeleteTargetError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsDeleteTargetVariables = {
  pathParams: TargetsDeleteTargetPathParams
  queryParams: TargetsDeleteTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Test Target
 */
export const fetchTargetsDeleteTarget = (variables: TargetsDeleteTargetVariables, signal?: AbortSignal) =>
  stoFetch<
    undefined,
    TargetsDeleteTargetError,
    undefined,
    {},
    TargetsDeleteTargetQueryParams,
    TargetsDeleteTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'delete', ...variables, signal })

/**
 * Delete an existing Test Target
 */
export const useTargetsDeleteTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, TargetsDeleteTargetError, TargetsDeleteTargetVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, TargetsDeleteTargetError, TargetsDeleteTargetVariables>({
    mutationFn: (variables: TargetsDeleteTargetVariables) =>
      fetchTargetsDeleteTarget({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetsFindTargetByIdPathParams = {
  /**
   * The ID of the Test Target to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsFindTargetByIdQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsFindTargetByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Et autem voluptatibus quia.
   */
  ['X-Api-Key']?: string
}

export type TargetsFindTargetByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsFindTargetByIdVariables = {
  headers?: TargetsFindTargetByIdHeaders
  pathParams: TargetsFindTargetByIdPathParams
  queryParams: TargetsFindTargetByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Test Target by ID
 */
export const fetchTargetsFindTargetById = (variables: TargetsFindTargetByIdVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Target,
    TargetsFindTargetByIdError,
    undefined,
    TargetsFindTargetByIdHeaders,
    TargetsFindTargetByIdQueryParams,
    TargetsFindTargetByIdPathParams
  >({ url: '/api/v2/targets/{id}', method: 'get', ...variables, signal })

/**
 * Find Test Target by ID
 */
export const useTargetsFindTargetById = <TData = Schemas.Target>(
  variables: TargetsFindTargetByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Target, TargetsFindTargetByIdError, TData>, 'queryKey' | 'queryFn'>,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Target, TargetsFindTargetByIdError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/targets/{id}', operationId: 'targetsFindTargetById', variables }),
    queryFn: ({ signal }) => fetchTargetsFindTargetById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type TargetsPatchTargetPathParams = {
  /**
   * The ID of the Test Target to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsPatchTargetQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsPatchTargetHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Sint debitis quis consectetur.
   */
  ['X-Api-Key']?: string
}

export type TargetsPatchTargetError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsPatchTargetVariables = {
  body?: Schemas.PatchTargetRequestBody
  headers?: TargetsPatchTargetHeaders
  pathParams: TargetsPatchTargetPathParams
  queryParams: TargetsPatchTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Update only certain fields on an existing Test Target
 */
export const fetchTargetsPatchTarget = (variables: TargetsPatchTargetVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Target,
    TargetsPatchTargetError,
    Schemas.PatchTargetRequestBody,
    TargetsPatchTargetHeaders,
    TargetsPatchTargetQueryParams,
    TargetsPatchTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'patch', ...variables, signal })

/**
 * Update only certain fields on an existing Test Target
 */
export const useTargetsPatchTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Target, TargetsPatchTargetError, TargetsPatchTargetVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Target, TargetsPatchTargetError, TargetsPatchTargetVariables>({
    mutationFn: (variables: TargetsPatchTargetVariables) =>
      fetchTargetsPatchTarget({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetsUpdateTargetPathParams = {
  /**
   * The ID of the Test Target to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsUpdateTargetQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /**
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsUpdateTargetHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Voluptas deserunt maxime facilis asperiores explicabo cum.
   */
  ['X-Api-Key']?: string
}

export type TargetsUpdateTargetError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsUpdateTargetVariables = {
  body: Schemas.UpdateTargetRequestBody
  headers?: TargetsUpdateTargetHeaders
  pathParams: TargetsUpdateTargetPathParams
  queryParams: TargetsUpdateTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Test Target
 */
export const fetchTargetsUpdateTarget = (variables: TargetsUpdateTargetVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.Target,
    TargetsUpdateTargetError,
    Schemas.UpdateTargetRequestBody,
    TargetsUpdateTargetHeaders,
    TargetsUpdateTargetQueryParams,
    TargetsUpdateTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'put', ...variables, signal })

/**
 * Update an existing Test Target
 */
export const useTargetsUpdateTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Target, TargetsUpdateTargetError, TargetsUpdateTargetVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Target, TargetsUpdateTargetError, TargetsUpdateTargetVariables>({
    mutationFn: (variables: TargetsUpdateTargetVariables) =>
      fetchTargetsUpdateTarget({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetVariantsListTargetVariantsPathParams = {
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
}

export type TargetVariantsListTargetVariantsQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /**
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @format int64
   * @minimum 0
   */
  page?: number
  /**
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @format int64
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /**
   * Resource name
   *
   * @example NodeGoat
   */
  name?: string
}

export type TargetVariantsListTargetVariantsHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Voluptates quas impedit vel sit.
   */
  ['X-Api-Key']?: string
}

export type TargetVariantsListTargetVariantsError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsListTargetVariantsVariables = {
  headers?: TargetVariantsListTargetVariantsHeaders
  pathParams: TargetVariantsListTargetVariantsPathParams
  queryParams: TargetVariantsListTargetVariantsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Scan Target Variants
 */
export const fetchTargetVariantsListTargetVariants = (
  variables: TargetVariantsListTargetVariantsVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.TargetVariantsListTargetVariantsResponseBody,
    TargetVariantsListTargetVariantsError,
    undefined,
    TargetVariantsListTargetVariantsHeaders,
    TargetVariantsListTargetVariantsQueryParams,
    TargetVariantsListTargetVariantsPathParams
  >({ url: '/api/v2/targets/{targetId}/variants', method: 'get', ...variables, signal })

/**
 * List a collection of Scan Target Variants
 */
export const useTargetVariantsListTargetVariants = <TData = Schemas.TargetVariantsListTargetVariantsResponseBody>(
  variables: TargetVariantsListTargetVariantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TargetVariantsListTargetVariantsResponseBody,
      TargetVariantsListTargetVariantsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<
    Schemas.TargetVariantsListTargetVariantsResponseBody,
    TargetVariantsListTargetVariantsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/v2/targets/{targetId}/variants',
      operationId: 'targetVariantsListTargetVariants',
      variables,
    }),
    queryFn: ({ signal }) => fetchTargetVariantsListTargetVariants({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type TargetVariantsCreateTargetVariantPathParams = {
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
}

export type TargetVariantsCreateTargetVariantQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsCreateTargetVariantHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Quidem voluptatem mollitia qui praesentium rerum.
   */
  ['X-Api-Key']?: string
}

export type TargetVariantsCreateTargetVariantError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsCreateTargetVariantVariables = {
  body: Schemas.CreateTargetVariantRequestBody
  headers?: TargetVariantsCreateTargetVariantHeaders
  pathParams: TargetVariantsCreateTargetVariantPathParams
  queryParams: TargetVariantsCreateTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Scan Target Variant
 */
export const fetchTargetVariantsCreateTargetVariant = (
  variables: TargetVariantsCreateTargetVariantVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    TargetVariantsCreateTargetVariantError,
    Schemas.CreateTargetVariantRequestBody,
    TargetVariantsCreateTargetVariantHeaders,
    TargetVariantsCreateTargetVariantQueryParams,
    TargetVariantsCreateTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants', method: 'post', ...variables, signal })

/**
 * Create a new Scan Target Variant
 */
export const useTargetVariantsCreateTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      TargetVariantsCreateTargetVariantError,
      TargetVariantsCreateTargetVariantVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    TargetVariantsCreateTargetVariantError,
    TargetVariantsCreateTargetVariantVariables
  >({
    mutationFn: (variables: TargetVariantsCreateTargetVariantVariables) =>
      fetchTargetVariantsCreateTargetVariant({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetVariantsDeleteTargetVariantPathParams = {
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /**
   * The ID of the Scan Target Variant to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsDeleteTargetVariantQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsDeleteTargetVariantError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsDeleteTargetVariantVariables = {
  pathParams: TargetVariantsDeleteTargetVariantPathParams
  queryParams: TargetVariantsDeleteTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Scan Target Variant
 */
export const fetchTargetVariantsDeleteTargetVariant = (
  variables: TargetVariantsDeleteTargetVariantVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    undefined,
    TargetVariantsDeleteTargetVariantError,
    undefined,
    {},
    TargetVariantsDeleteTargetVariantQueryParams,
    TargetVariantsDeleteTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'delete', ...variables, signal })

/**
 * Delete an existing Scan Target Variant
 */
export const useTargetVariantsDeleteTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      TargetVariantsDeleteTargetVariantError,
      TargetVariantsDeleteTargetVariantVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    undefined,
    TargetVariantsDeleteTargetVariantError,
    TargetVariantsDeleteTargetVariantVariables
  >({
    mutationFn: (variables: TargetVariantsDeleteTargetVariantVariables) =>
      fetchTargetVariantsDeleteTargetVariant({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TargetVariantsFindTargetVariantByIdPathParams = {
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /**
   * The ID of the Scan Target Variant to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsFindTargetVariantByIdQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsFindTargetVariantByIdHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Velit aut quisquam aut.
   */
  ['X-Api-Key']?: string
}

export type TargetVariantsFindTargetVariantByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsFindTargetVariantByIdVariables = {
  headers?: TargetVariantsFindTargetVariantByIdHeaders
  pathParams: TargetVariantsFindTargetVariantByIdPathParams
  queryParams: TargetVariantsFindTargetVariantByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Scan Target Variant by ID
 */
export const fetchTargetVariantsFindTargetVariantById = (
  variables: TargetVariantsFindTargetVariantByIdVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.TargetVariant,
    TargetVariantsFindTargetVariantByIdError,
    undefined,
    TargetVariantsFindTargetVariantByIdHeaders,
    TargetVariantsFindTargetVariantByIdQueryParams,
    TargetVariantsFindTargetVariantByIdPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'get', ...variables, signal })

/**
 * Find Scan Target Variant by ID
 */
export const useTargetVariantsFindTargetVariantById = <TData = Schemas.TargetVariant>(
  variables: TargetVariantsFindTargetVariantByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TargetVariant, TargetVariantsFindTargetVariantByIdError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TargetVariant, TargetVariantsFindTargetVariantByIdError, TData>({
    queryKey: queryKeyFn({
      path: '/api/v2/targets/{targetId}/variants/{id}',
      operationId: 'targetVariantsFindTargetVariantById',
      variables,
    }),
    queryFn: ({ signal }) => fetchTargetVariantsFindTargetVariantById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type TargetVariantsUpdateTargetVariantPathParams = {
  /**
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /**
   * The ID of the Scan Target Variant to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsUpdateTargetVariantQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsUpdateTargetVariantHeaders = {
  /**
   * Harness personal or service access token
   *
   * @example Temporibus odit aut corrupti.
   */
  ['X-Api-Key']?: string
}

export type TargetVariantsUpdateTargetVariantError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsUpdateTargetVariantVariables = {
  body: Schemas.UpdateTargetVariantRequestBody
  headers?: TargetVariantsUpdateTargetVariantHeaders
  pathParams: TargetVariantsUpdateTargetVariantPathParams
  queryParams: TargetVariantsUpdateTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Scan Target Variant
 */
export const fetchTargetVariantsUpdateTargetVariant = (
  variables: TargetVariantsUpdateTargetVariantVariables,
  signal?: AbortSignal,
) =>
  stoFetch<
    Schemas.TargetVariant,
    TargetVariantsUpdateTargetVariantError,
    Schemas.UpdateTargetVariantRequestBody,
    TargetVariantsUpdateTargetVariantHeaders,
    TargetVariantsUpdateTargetVariantQueryParams,
    TargetVariantsUpdateTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'put', ...variables, signal })

/**
 * Update an existing Scan Target Variant
 */
export const useTargetVariantsUpdateTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TargetVariant,
      TargetVariantsUpdateTargetVariantError,
      TargetVariantsUpdateTargetVariantVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.TargetVariant,
    TargetVariantsUpdateTargetVariantError,
    TargetVariantsUpdateTargetVariantVariables
  >({
    mutationFn: (variables: TargetVariantsUpdateTargetVariantVariables) =>
      fetchTargetVariantsUpdateTargetVariant({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type TokenIssueTokenQueryParams = {
  /**
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId?: string
}

export type TokenIssueTokenHeaders = {
  /**
   * Harness internal shared secret
   *
   * @example 3q7uiERGH78heq3weg
   */
  ['X-Harness-Token']: string
}

export type TokenIssueTokenError = Fetcher.ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 429
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TokenIssueTokenVariables = {
  headers: TokenIssueTokenHeaders
  queryParams?: TokenIssueTokenQueryParams
} & StoContext['fetcherOptions']

/**
 * Issue a cross-service token
 */
export const fetchTokenIssueToken = (variables: TokenIssueTokenVariables, signal?: AbortSignal) =>
  stoFetch<
    Schemas.TokenResponse,
    TokenIssueTokenError,
    undefined,
    TokenIssueTokenHeaders,
    TokenIssueTokenQueryParams,
    {}
  >({ url: '/api/v2/token', method: 'get', ...variables, signal })

/**
 * Issue a cross-service token
 */
export const useTokenIssueToken = <TData = Schemas.TokenResponse>(
  variables: TokenIssueTokenVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TokenResponse, TokenIssueTokenError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TokenResponse, TokenIssueTokenError, TData>({
    queryKey: queryKeyFn({ path: '/api/v2/token', operationId: 'tokenIssueToken', variables }),
    queryFn: ({ signal }) => fetchTokenIssueToken({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type QueryOperation =
  | {
      path: '/api/usage'
      operationId: 'usageReportUsage'
      variables: UsageReportUsageVariables
    }
  | {
      path: '/api/usage/all-accounts'
      operationId: 'usageUsageAllAccounts'
      variables: UsageUsageAllAccountsVariables
    }
  | {
      path: '/api/v2/exemptions'
      operationId: 'exemptionsListExemptions'
      variables: ExemptionsListExemptionsVariables
    }
  | {
      path: '/api/v2/exemptions/{id}'
      operationId: 'exemptionsFindExemptionById'
      variables: ExemptionsFindExemptionByIdVariables
    }
  | {
      path: '/api/v2/frontend/execution-for-repo'
      operationId: 'frontendExecutionForRepo'
      variables: FrontendExecutionForRepoVariables
    }
  | {
      path: '/api/v2/frontend/expiring-exemptions/{executionId}'
      operationId: 'frontendExpiringExemptions'
      variables: FrontendExpiringExemptionsVariables
    }
  | {
      path: '/api/v2/frontend/issue-counts'
      operationId: 'frontendExecutionIssueCounts'
      variables: FrontendExecutionIssueCountsVariables
    }
  | {
      path: '/api/v2/frontend/issue-exemption/{exemptionId}'
      operationId: 'frontendIssueForExemption'
      variables: FrontendIssueForExemptionVariables
    }
  | {
      path: '/api/v2/frontend/overview/baselines'
      operationId: 'frontendOverviewBaselines'
      variables: FrontendOverviewBaselinesVariables
    }
  | {
      path: '/api/v2/frontend/overview/historical-counts'
      operationId: 'frontendOverviewHistoricalCounts'
      variables: FrontendOverviewHistoricalCountsVariables
    }
  | {
      path: '/api/v2/frontend/pipeline-security/issues'
      operationId: 'frontendPipelineSecurityIssues'
      variables: FrontendPipelineSecurityIssuesVariables
    }
  | {
      path: '/api/v2/frontend/pipeline-security/steps'
      operationId: 'frontendPipelineSecuritySteps'
      variables: FrontendPipelineSecurityStepsVariables
    }
  | {
      path: '/api/v2/frontend/security-review'
      operationId: 'frontendSecurityReview'
      variables: FrontendSecurityReviewVariables
    }
  | {
      path: '/api/v2/frontend/test-targets'
      operationId: 'frontendTestTargets'
      variables: FrontendTestTargetsVariables
    }
  | {
      path: '/api/v2/issues'
      operationId: 'issuesListIssues'
      variables: IssuesListIssuesVariables
    }
  | {
      path: '/api/v2/issues/{id}'
      operationId: 'issuesFindIssueById'
      variables: IssuesFindIssueByIdVariables
    }
  | {
      path: '/api/v2/products'
      operationId: 'productsListProducts'
      variables: ProductsListProductsVariables
    }
  | {
      path: '/api/v2/products/{id}'
      operationId: 'productsFindProductById'
      variables: ProductsFindProductByIdVariables
    }
  | {
      path: '/api/v2/reference-identifiers/{refId}'
      operationId: 'referenceIdentifiersGetByReferenceId'
      variables: ReferenceIdentifiersGetByReferenceIdVariables
    }
  | {
      path: '/api/v2/scans'
      operationId: 'scansListScans'
      variables: ScansListScansVariables
    }
  | {
      path: '/api/v2/scans/{id}'
      operationId: 'scansFindScanById'
      variables: ScansFindScanByIdVariables
    }
  | {
      path: '/api/v2/scans/{id}/issue/{issueId}'
      operationId: 'scansScanIssue'
      variables: ScansScanIssueVariables
    }
  | {
      path: '/api/v2/scans/{id}/issues'
      operationId: 'scansScanIssues'
      variables: ScansScanIssuesVariables
    }
  | {
      path: '/api/v2/scans/{id}/issues/counts'
      operationId: 'scansScanIssueCounts'
      variables: ScansScanIssueCountsVariables
    }
  | {
      path: '/api/v2/ssca-frontend/execution-summary/{executionId}'
      operationId: 'sSCAFrontendSscaExecutionSummary'
      variables: SSCAFrontendSscaExecutionSummaryVariables
    }
  | {
      path: '/api/v2/system/health'
      operationId: 'systemHealth'
      variables: SystemHealthVariables
    }
  | {
      path: '/api/v2/system/version'
      operationId: 'systemVersion'
      variables: SystemVersionVariables
    }
  | {
      path: '/api/v2/targets'
      operationId: 'targetsListTargets'
      variables: TargetsListTargetsVariables
    }
  | {
      path: '/api/v2/targets/{id}'
      operationId: 'targetsFindTargetById'
      variables: TargetsFindTargetByIdVariables
    }
  | {
      path: '/api/v2/targets/{targetId}/variants'
      operationId: 'targetVariantsListTargetVariants'
      variables: TargetVariantsListTargetVariantsVariables
    }
  | {
      path: '/api/v2/targets/{targetId}/variants/{id}'
      operationId: 'targetVariantsFindTargetVariantById'
      variables: TargetVariantsFindTargetVariantByIdVariables
    }
  | {
      path: '/api/v2/token'
      operationId: 'tokenIssueToken'
      variables: TokenIssueTokenVariables
    }
